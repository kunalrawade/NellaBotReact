import React, { Component } from 'react'
import shallowequal from 'shallowequal'

export const speechRecognitionAvailable = () =>
  ('SpeechRecognition' in window)
  || ('webkitSpeechRecognition' in window)
  || ('mozSpeechRecognition' in window)
  || ('msSpeechRecognition' in window)


const createSpeechRecognition = (lang, interimResults) => {
  const SpeechRecognition =  window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition
  const recognition = new SpeechRecognition()
  recognition.lang = lang
  recognition.continuous = false
  recognition.interimResults = interimResults
  return recognition
}


const attachEvents = (recognition, {onEnd = ()=>{}, onError = ()=>{}, onStart = ()=>{}, onResult = ()=>{}}) => {
  recognition.onstart = onStart
  recognition.onend = onEnd
  recognition.onerror = onError
  recognition.onend = onEnd
  recognition.onresult = onResult
  return recognition
}

class SpeechRecognizer extends Component {
  componentDidMount() {
    this.initRecognition(this.props)
  }
  componentWillReceiveProps(nextProps) {
    if(!shallowequal(nextProps, this.props)) {
      this.initRecognition(nextProps)
    }
  }
  componentWillUnmount() {
    this.abortRecognition()
  }
  abortRecognition() {
    if(this.recognition) {
      this.recognition = attachEvents(this.recognition, {}) // remove listeners before aborting
      this.recognition.abort()
    }
  }
  initRecognition(props) {
    const { lang='en-GB', onNotAvailable , onTempResult, onResult, onStart, onError, onEnd } = this.props

    // Check availability
    if (!speechRecognitionAvailable()) {
      return onNotAvailable && onNotAvailable()
    }

    // Abort previous instances of recognition already running
    this.abortRecognition()

    // Create new recognition
    const interimResult = !!onTempResult
    const recognition = attachEvents(createSpeechRecognition(lang, interimResult), {
      onStart: (e) => {
        onStart && onStart(e)
      },
      onEnd: (e) => {
        onEnd && onEnd(e)
        this.initRecognition() // restart
      },
      onError: (error) => {
        onError && onError(error)
      },
      onResult: (e) => {
        const transcript = e && e.results && e.results[0] && e.results[0][0]
          ?  e.results[0][0]
          : null
        const isFinal = e && e.results && e.results[0]
          ? e.results[0].isFinal
          : null

        const cb = isFinal
          ? onResult
          : onTempResult
        cb && cb(transcript)
      }
    })

    // Start recognition
    recognition.start()

    // Store recognition so that it can be aborted
    this.recognition = recognition
  }

  render() {
    return null
  }
}

export default SpeechRecognizer
